---
title: "task2"
editor: visual
---

## Task 2 Reading Delimited Data

#### 1.  Read this data into R directly from the URL using functions from the tidyverse. Notice that the data doesn\'t include column names - add those (in a manner of your choosing). Print out the tibble (just call the object name).

```{r}
library(readr)
library(dplyr)
library(tibble)

url <- "https://www4.stat.ncsu.edu/~online/datasets/glass.data"

col_names <- c("Id","RI","Na","Mg","Al","Si","K","Ca","Ba","Fe","Type_of_glass")

glass = read_csv(
  url,
  col_names = col_names,
  col_types = cols(
    Id = col_integer(),
    RI = col_double(),
    Na = col_double(),
    Mg = col_double(),
    Al = col_double(),
    Si = col_double(),
    K  = col_double(),
    Ca = col_double(),
    Ba = col_double(),
    Fe = col_double(),
    Type_of_glass = col_integer()
  )
)
glass
```

#### 2.  Start a chain that would overwrite the Type_of_glass variable using mutate(). Create a character string version (that is, replace 1 with \"building_windows_float_processed\", 2 with \"building_win\...\", etc.) instead (see the variable descriptions above to give meaningful values). (If you are familiar with factors, feel free to use that instead of a character string variable - otherwise, think if/then/else via ifelse().)

#### 3. Continue your chain and keep only observations where the Fe variable is less than 0.2 and the Type of Glass is either \"tableware\" or \"headlamps\".

```{r}
# Recode and filter in one chain
glass_filtered = glass |>
  mutate(Type_of_glass = case_when(
    Type_of_glass == 1 ~ "building_windows_float_processed",
    Type_of_glass == 2 ~ "building_windows_non_float_processed",
    Type_of_glass == 3 ~ "vehicle_windows_float_processed",
    Type_of_glass == 4 ~ "vehicle_windows_non_float_processed",
    Type_of_glass == 5 ~ "containers",
    Type_of_glass == 6 ~ "tableware",
    Type_of_glass == 7 ~ "headlamps"
  )) |>
  filter(Fe < 0.2, Type_of_glass %in% c("tableware", "headlamps"))

# Show results
glass_filtered

```

### Yeast Data

#### 1. Read this data into R directly from the URL using functions from the tidyverse. Notice that the data doesn\'t include column names - add those (in a manner of your choosing). Print out the tibble (just call the object name).

```{r}
library(readr)
library(dplyr)

url = "https://www4.stat.ncsu.edu/~online/datasets/yeast.data"

col_names = c("seq_name","mcg","gvh","alm","mit",
               "erl","pox","vac","nuc","class")

yeast = read_table(
  file = url,
  col_names = col_names,
  col_types = cols(
    seq_name = col_character(),
    mcg = col_double(),
    gvh = col_double(),
    alm = col_double(),
    mit = col_double(),
    erl = col_double(),  
    pox = col_double(),  
    vac = col_double(),
    nuc = col_double(),
    class = col_character()
  )
)

yeast
```

#### 2. Start a chain that removes the seq_name and nuc columns.

```{r}
# drop seq_name and nuc
yeast_clean = yeast |>
  select(-seq_name, -nuc)

```

#### 3. Continue your chain to add columns corresponding to the mean and median of each numeric variable (mcg, gvh, alm, mit, erl, pox, and vac) at each class grouping (see the across() function as we did in the dplyr video!)

```{r}
# summarize by class 
yeast_summary = yeast_clean |>
  group_by(class) |>
  summarise(
    across(
      c(mcg, gvh, alm, mit, erl, pox, vac),
      list(mean = mean, median = median),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  )

yeast_summary
```

#### 
